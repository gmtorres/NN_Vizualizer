[{"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\index.js":"1","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\App.js":"2","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\reportWebVitals.js":"3","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Visual\\NN.jsx":"4","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Visual\\Edge\\Edge.jsx":"5","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Visual\\Node\\Node.jsx":"6","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Navbar\\Navbar.jsx":"7","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\NeuralNetwork\\NeuralNetwork.js":"8","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Layout\\Layout.jsx":"9","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Visual\\VisualNN.jsx":"10","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Layout\\InfoPanel.jsx":"11","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Layout\\Topbar\\Topbar.jsx":"12","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Layout\\Topbar\\TopbarData.jsx":"13","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Info\\InfoBasic.jsx":"14","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Info\\Feedback.jsx":"15","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\DataGrid\\DataGrid.jsx":"16","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\DataGrid\\DataEntry.jsx":"17","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\DataGrid\\DataValue.jsx":"18","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\DataGrid\\DataAux.jsx":"19","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\NeuralNetwork\\samplesNN.js":"20","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Expression\\Expression.jsx":"21","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\NeuralNetwork\\activation.js":"22","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Visual\\LayerDropDown.jsx":"23","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Info\\FeedForward.jsx":"24"},{"size":500,"mtime":499162500000,"results":"25","hashOfConfig":"26"},{"size":322,"mtime":1609681590695,"results":"27","hashOfConfig":"26"},{"size":362,"mtime":499162500000,"results":"28","hashOfConfig":"26"},{"size":5421,"mtime":1611972892588,"results":"29","hashOfConfig":"26"},{"size":1297,"mtime":1609681777928,"results":"30","hashOfConfig":"26"},{"size":1181,"mtime":1610240867381,"results":"31","hashOfConfig":"26"},{"size":264,"mtime":1609617921949,"results":"32","hashOfConfig":"26"},{"size":18089,"mtime":1612013995809,"results":"33","hashOfConfig":"26"},{"size":12969,"mtime":1612021459437,"results":"34","hashOfConfig":"26"},{"size":1451,"mtime":1611451298420,"results":"35","hashOfConfig":"26"},{"size":1344,"mtime":1610298182956,"results":"36","hashOfConfig":"26"},{"size":978,"mtime":1609687986324,"results":"37","hashOfConfig":"26"},{"size":590,"mtime":1612033556618,"results":"38","hashOfConfig":"26"},{"size":3630,"mtime":1612090687915,"results":"39","hashOfConfig":"26"},{"size":135,"mtime":1609683245134,"results":"40","hashOfConfig":"26"},{"size":2276,"mtime":1611451078580,"results":"41","hashOfConfig":"26"},{"size":2439,"mtime":1611451078578,"results":"42","hashOfConfig":"26"},{"size":1111,"mtime":1610561043200,"results":"43","hashOfConfig":"26"},{"size":597,"mtime":1611451078577,"results":"44","hashOfConfig":"26"},{"size":765,"mtime":1611969496795,"results":"45","hashOfConfig":"26"},{"size":585,"mtime":1612033317478,"results":"46","hashOfConfig":"26"},{"size":469,"mtime":1611452544954,"results":"47","hashOfConfig":"26"},{"size":1754,"mtime":1611452232829,"results":"48","hashOfConfig":"26"},{"size":5448,"mtime":1612090761286,"results":"49","hashOfConfig":"26"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},"gh9ocp",{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67","usedDeprecatedRules":"52"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"88","messages":"89","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"90","messages":"91","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"92","messages":"93","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"94","messages":"95","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"96","messages":"97","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"52"},{"filePath":"98","messages":"99","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\index.js",[],["100","101"],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\App.js",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\reportWebVitals.js",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Visual\\NN.jsx",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Visual\\Edge\\Edge.jsx",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Visual\\Node\\Node.jsx",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Navbar\\Navbar.jsx",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\NeuralNetwork\\NeuralNetwork.js",["102"],"import activation from \"./activation\"\r\n\r\nexport default class NeuralNetwork{\r\n    constructor(input_size,output_size){\r\n        \r\n        this.n_layers = 3;\r\n\r\n        this.bias = true;\r\n\r\n        this.learning_rate = 0.02;\r\n        \r\n        this.layers = [];\r\n        this.layer_activation = []\r\n        this.max_height = 0;\r\n\r\n        this.createRandomNN(input_size,output_size);\r\n\r\n        this.expression = []\r\n    }\r\n\r\n    getInputLayerSize(){\r\n        if(this.bias)\r\n            return this.layers[0].length - 1;\r\n        return this.layers[0].length;\r\n    }\r\n\r\n    getOutputLayerSize(){\r\n        return this.layers[this.layers.length-1].length;\r\n    }\r\n\r\n    getLayerSize(l){\r\n        if(l === this.layers.length-1)\r\n            return this.layers[l].length;\r\n        if(this.bias)\r\n            return this.layers[l].length - 1;\r\n        return this.layers[l].length;\r\n    }\r\n\r\n    addInputNode(){\r\n        let edges = [];\r\n        for(let i = 0; i < this.getLayerSize(1);i++){\r\n            edges.push(Math.random());\r\n        }\r\n        this.layers[0].splice(this.getLayerSize(0),0,{value : NaN, edges : edges, edges_old : [...edges]});\r\n        if(this.layers[0].length > this.max_height)\r\n            this.max_height = this.layers[0].length;\r\n    }\r\n\r\n    addOutputNode(){\r\n        for(let  i = 0; i < this.layers[this.layers.length-2].length;i++){\r\n            this.layers[this.layers.length-2][i].edges.push(Math.random());\r\n        }\r\n        this.layers[this.layers.length-1].push({value : NaN, edges : [1]});\r\n        if(this.layers[this.layers.length-1].length > this.max_height)\r\n            this.max_height = this.layers[this.layers.length-1].length;\r\n    }\r\n    addNode(layer){\r\n        for(let  i = 0; i < this.layers[layer-1].length;i++){\r\n            this.layers[layer-1][i].edges.push(Math.random());\r\n        }\r\n        let edges = [];\r\n        for(let i = 0; i < this.getLayerSize(layer+1); i++){\r\n            edges.push(Math.random());\r\n        }\r\n        this.layers[layer].splice(this.getLayerSize(layer),0,{value : NaN, edges : edges, edges_old : [...edges]});\r\n        if(this.layers[layer].length > this.max_height)\r\n            this.max_height = this.layers[layer].length;\r\n    }\r\n\r\n    addLayer(layer){\r\n        for(let i = 0; i < this.layers[layer].length;i++){\r\n            this.layers[layer][i].edges = [];\r\n        }\r\n        this.layers.splice(layer+1,0,[]);\r\n        if(this.bias){\r\n            let edges = [];\r\n            for(let i = 0; i < this.getLayerSize(layer+2); i++){\r\n                edges.push(Math.random());\r\n            }\r\n            this.layers[layer+1].push({value : 1, edges : edges , edges_old : [...edges]});\r\n\r\n        }\r\n        this.layer_activation.splice(layer+1,0,null);\r\n        this.setLayerActivation(layer+1,\"sigm\");\r\n        this.addNode(layer+1);\r\n    }\r\n\r\n    deleteInputNode(index){\r\n        this.layers[0].splice(index,1);\r\n        this.max_height = 0;\r\n        for(let i = 0; i < this.layers.length;i++)\r\n            if(this.layers[i].length > this.max_height)\r\n                this.max_height = this.layers[i].length\r\n    }\r\n    deleteOutputNode(index){\r\n        for(let  i = 0; i < this.layers[this.layers.length-2].length;i++){\r\n            this.layers[this.layers.length-2][i].edges.splice(index,1);\r\n        }\r\n        this.layers[this.layers.length-1].splice(index,1);\r\n        this.max_height = 0;\r\n        for(let i = 0; i < this.layers.length;i++)\r\n            if(this.layers[i].length > this.max_height)\r\n                this.max_height = this.layers[i].length\r\n    }\r\n\r\n    setLayerActivation(layer,name){\r\n        if(!activation.hasOwnProperty(name)) return;\r\n        this.layer_activation[layer] = {name : name, activation : activation[name]}\r\n    }\r\n\r\n\r\n    resetVars(){\r\n        this.step_layer = null;\r\n        this.step_node = null;\r\n    }\r\n\r\n    createRandomNN(input_size,output_size){\r\n        this.resetVars();\r\n        this.layers = [];\r\n        this.max_height = 0;\r\n        for(let l = 0; l < this.n_layers; l++){\r\n            let layer = [];\r\n            let height = Math.floor(Math.random() * 3) + 2;\r\n            //let height = 2;\r\n            if(l === 0 && input_size !== null && input_size !== undefined)\r\n                height = input_size\r\n            if(l === this.n_layers-1 && output_size !== null && output_size !== undefined)\r\n                height = output_size\r\n            for(let n = 0; n < height; n++){\r\n                layer.push({value : Math.round(Math.random()*1000)/1000, edges : []});\r\n            }\r\n            if(this.bias && l !== this.n_layers-1)\r\n                layer.push({value : 1, edges : []});\r\n            if(layer.length > this.max_height) this.max_height = layer.length;\r\n            this.layers.push(layer);\r\n            this.setLayerActivation(l,\"sigm\");\r\n        }\r\n        this.randomize()\r\n    }\r\n\r\n    randomize(){\r\n        this.resetVars();\r\n        for(let l = 0; l < this.layers.length; l++){\r\n            for(let n = 0; n < this.layers[l].length; n++){\r\n                this.layers[l][n].edges = [];\r\n                if(l === this.layers.length-1)\r\n                    this.layers[l][n].edges.push(1);\r\n                else{\r\n                    let size = this.layers[l+1].length;\r\n                    if(l+1 < this.layers.length - 1 && this.bias) size -= 1\r\n                    for(let n2 = 0; n2 < size; n2++)\r\n                        this.layers[l][n].edges.push(Math.random());\r\n                    this.layers[l][n].edges_old = this.layers[l][n].edges\r\n                }\r\n            }\r\n        }\r\n        this.clearNodes();\r\n    }\r\n\r\n    clearNodes(){\r\n        for(let l = 0; l < this.layers.length; l++){\r\n            let size = this.layers[l].length;\r\n            if(l < this.layers.length-1 && this.bias) size -= 1\r\n            for(let n = 0; n < size; n++){\r\n                this.layers[l][n].value = NaN;\r\n                this.layers[l][n].error = NaN;\r\n            }\r\n        }\r\n    }\r\n    setInputLayer(input_data){\r\n        if(input_data != null){\r\n            for(let i = 0; i < input_data.length;i++){\r\n                this.layers[0][i].value = parseFloat(input_data[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    feedforward(input_data, output_data){\r\n        this.setInputLayer(input_data)\r\n        for(let l = 1; l < this.layers.length; l++){\r\n            //let layer = this.layers[l];\r\n            let layer_prev = this.layers[l-1];\r\n            let activation = this.layer_activation[l].activation.func\r\n            for(let n = 0; n < this.getLayerSize(l); n++){\r\n                let sum = 0;\r\n                for(let prev_n = 0; prev_n < layer_prev.length;prev_n++){\r\n                    sum+= layer_prev[prev_n].value * layer_prev[prev_n].edges[n];\r\n                }\r\n                this.layers[l][n].value = activation(sum);\r\n            }\r\n        }\r\n        //let error = 0;\r\n        if(output_data != null){\r\n            let last = this.layers.length-1;\r\n            for(let i = 0; i < this.layers[last].length; i++){\r\n                this.layers[last][i].error = this.layers[last][i].value - output_data[i];\r\n                //error += this.layers[last][i].error * this.layers[last][i].error;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    feedforwardStepNode(input_data, output_data){\r\n        this.expression = []\r\n        if(this.step_node == null){\r\n            this.step_node = 0;\r\n            this.clearNodes();\r\n            this.setInputLayer(input_data);\r\n            if(this.step_layer == null)\r\n                this.step_layer = 1;\r\n            return false;\r\n        }\r\n\r\n        let layer_prev = this.layers[this.step_layer-1];\r\n        let sum = 0;\r\n\r\n        let in_expression = '';\r\n        in_expression += \"in=\"\r\n\r\n        for(let prev_n = 0; prev_n < layer_prev.length;prev_n++){\r\n            in_expression += layer_prev[prev_n].value.toFixed(4) + \"*\" + layer_prev[prev_n].edges[this.step_node].toFixed(4)\r\n            if(prev_n !== layer_prev.length - 1)\r\n                in_expression +=\"+\"\r\n            sum+= layer_prev[prev_n].value * layer_prev[prev_n].edges[this.step_node];\r\n        }\r\n        in_expression += \" = \" + sum.toFixed(4);\r\n        this.expression.push(String.raw`${in_expression}`)\r\n\r\n        let out_expression = \"\"\r\n        this.layers[this.step_layer][this.step_node].value = this.layer_activation[this.step_layer].activation.func(sum);\r\n        out_expression += \"out=activation(in)=\"+ this.layer_activation[this.step_layer].name +\"(\" + sum.toFixed(4) + \")=\" + this.layers[this.step_layer][this.step_node].value.toFixed(4)\r\n\r\n        this.expression.push(String.raw`${out_expression}`)\r\n\r\n        this.step_node++;\r\n        if(this.step_node >= this.getLayerSize(this.step_layer)){\r\n            this.step_node = 0;\r\n            this.step_layer++;\r\n        }\r\n        if(this.step_layer >= this.layers.length){\r\n            this.step_layer = null;\r\n            this.step_node = null;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    feedforwardStepLayer(input_data, output_data){\r\n        if(this.step_layer == null){\r\n            this.step_layer = 1;\r\n            this.clearNodes();\r\n            this.setInputLayer(input_data);\r\n            return false;\r\n        }\r\n        //let layer = this.layers[this.step_layer];\r\n        let layer_prev = this.layers[this.step_layer-1];\r\n        let n = (this.step_node == null) ? 0 : this.step_node;\r\n        let activation = this.layer_activation[this.step_layer].activation.func\r\n        for(; n < this.getLayerSize(this.step_layer); n++){\r\n            let sum = 0;\r\n            for(let prev_n = 0; prev_n < layer_prev.length;prev_n++){\r\n                sum+= layer_prev[prev_n].value * layer_prev[prev_n].edges[n];\r\n            }\r\n            this.layers[this.step_layer][n].value = activation(sum);\r\n        }\r\n        this.step_layer++;\r\n        this.step_node = 0;\r\n        if(this.step_layer >= this.layers.length){\r\n            this.step_layer = null;\r\n            this.step_node = null;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    train(input_data, output_data, times = 1){\r\n        for(let t = 0; t < times; t++)\r\n            for(let i = 0; i < input_data.length; i++)\r\n                this.backpropagation(input_data[i],output_data[i]);\r\n    }\r\n\r\n    backpropagation(input_data, output_data){\r\n        this.feedforward(input_data,output_data);\r\n        let last = this.layers.length-1;\r\n        for(let i = 0; i < this.layers[last].length;i++){\r\n            let node = this.layers[last][i];\r\n            node.derivative = this.layer_activation[0].activation.deriv(node.value) * node.error;\r\n        }\r\n        for(let l = last-1; l >= 0; l--){\r\n            let size_layer = this.layers[l].length;\r\n            let derivative = this.layer_activation[l].activation.deriv\r\n            for(let i = 0; i < size_layer; i++){\r\n                let node = this.layers[l][i];\r\n                let d_sum = 0;\r\n                for(let a = 0; a < node.edges.length;a++){\r\n                    d_sum += this.layers[l][i].edges[a] * this.layers[l+1][a].derivative;\r\n                }\r\n                node.derivative = d_sum * derivative(node.value);\r\n            }\r\n        }\r\n        for(let l = last-1; l >= 0; l--){\r\n            let size_layer = this.layers[l].length;\r\n            for(let i = 0; i < size_layer; i++){\r\n                let node = this.layers[l][i];\r\n                for(let a = 0; a < node.edges.length;a++){\r\n                    if(!isFinite(node.edges[a])) continue;\r\n                    node.edges[a] -= node.value * this.layers[l+1][a].derivative * this.learning_rate;\r\n                    console.log(node.edges[a]);\r\n                }\r\n            }   \r\n        }\r\n    }\r\n\r\n    backpropagationLayer(input_data, output_data){\r\n        if(this.step_layer == null){\r\n            this.feedforward(input_data,output_data);\r\n            this.step_layer = this.layers.length-1;\r\n            return false;\r\n        }\r\n        \r\n        let prev_layer = this.step_layer - 1;\r\n\r\n        if(this.step_layer === this.layers.length-1){\r\n            for(let i = 0; i < this.layers[this.step_layer].length;i++){\r\n                let node = this.layers[this.step_layer][i];\r\n                node.derivative = this.layer_activation[0].activation.deriv(node.value) * node.error;\r\n            }\r\n        }else{\r\n            let size_layer = this.layers[this.step_layer].length;\r\n            let derivative = this.layer_activation[this.step_layer].activation.deriv\r\n            for(let i = 0; i < size_layer; i++){\r\n                let node = this.layers[this.step_layer][i];\r\n                let d_sum = 0;\r\n                for(let a = 0; a < node.edges.length;a++){\r\n                    d_sum += this.layers[this.step_layer][i].edges_old[a] * this.layers[this.step_layer+1][a].derivative;\r\n                }\r\n                node.derivative = d_sum * derivative(node.value);\r\n            }\r\n        }\r\n\r\n        let size_layer = this.layers[prev_layer].length;\r\n        for(let i = 0; i < size_layer; i++){\r\n            let node = this.layers[prev_layer][i];\r\n            for(let a = 0; a < node.edges.length;a++){\r\n                if(!isFinite(node.edges[a])) continue;\r\n                node.edges_old[a] = node.edges[a];\r\n                node.edges[a] -= node.value * this.layers[this.step_layer][a].derivative * this.learning_rate;\r\n                console.log(node.edges[a])\r\n            }\r\n        }\r\n\r\n        this.step_layer--;\r\n        this.step_node = 0;\r\n        if(this.step_layer <= 0){\r\n            this.step_layer = null;\r\n            this.step_node = null;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    backpropagationNode(input_data, output_data){\r\n        this.expression = []\r\n        if(this.step_node == null){\r\n            this.feedforward(input_data,output_data);\r\n            this.step_node = 0;\r\n            if(this.step_layer == null)\r\n                this.step_layer = this.layers.length-1;\r\n            return false;\r\n        }\r\n\r\n        let node_expression = String.raw`\\Delta `;\r\n        node_expression += `node^${this.step_layer}_${this.step_node} = `\r\n\r\n        let prev_layer = this.step_layer - 1;\r\n\r\n        if(this.step_layer === this.layers.length-1){\r\n            \r\n            let node = this.layers[this.step_layer][this.step_node];\r\n            node.derivative = this.layer_activation[0].activation.deriv(node.value) * node.error;\r\n            node_expression += this.layer_activation[0].activation.deriv(node.value).toFixed(4) + \"*\" + node.error.toFixed(4)\r\n            node_expression += \"=\" + node.derivative.toFixed(4)\r\n        }else{\r\n            let derivative = this.layer_activation[this.step_layer].activation.deriv\r\n            \r\n            let node = this.layers[this.step_layer][this.step_node];\r\n            let d_sum = 0;\r\n            for(let a = 0; a < node.edges.length;a++){\r\n                d_sum += this.layers[this.step_layer][this.step_node].edges_old[a] * this.layers[this.step_layer+1][a].derivative;\r\n                node_expression += this.layers[this.step_layer][this.step_node].edges_old[a].toFixed(4) + \"*\" + this.layers[this.step_layer+1][a].derivative.toFixed(4)\r\n                if(a != node.edges.length - 1) node_expression += \"+\"\r\n            }\r\n            node.derivative = d_sum * derivative(node.value);\r\n            node_expression += \"=\" + node.derivative.toFixed(4)\r\n        }\r\n        this.expression.push(node_expression)\r\n        \r\n        let size_layer = this.layers[prev_layer].length;\r\n        for(let i = 0; i < size_layer; i++){\r\n            let weight_expression = \"\";\r\n            let node = this.layers[prev_layer][i];\r\n            \r\n            if(!isFinite(node.edges[this.step_node])) continue;\r\n            node.edges_old[this.step_node] = node.edges[this.step_node];\r\n            node.edges[this.step_node] -= node.value * this.layers[this.step_layer][this.step_node].derivative * this.learning_rate;\r\n            console.log(node.edges[this.step_node])\r\n            weight_expression += `weight_{${i},${this.step_node}}^${prev_layer}=` + node.edges_old[this.step_node].toFixed(4) + \"-\" + node.value.toFixed(4) + \"*\" + this.layers[this.step_layer][this.step_node].derivative.toFixed(4) + \"*\" + this.learning_rate.toFixed(4)\r\n            weight_expression += \"=\" + node.edges[this.step_node].toFixed(4)\r\n            this.expression.push(weight_expression)\r\n        }\r\n        \r\n\r\n        this.step_node++;\r\n        if(this.step_node >= this.getLayerSize(this.step_layer)){\r\n            this.step_node = 0;\r\n            this.step_layer--;\r\n        }\r\n        if(this.step_layer <= 0){\r\n            this.step_layer = null;\r\n            this.step_node = null;\r\n            return true;\r\n        }\r\n        return false;\r\n\r\n    }\r\n\r\n\r\n    getRepresentation(){\r\n        return {\r\n            representation : this.layers,\r\n            height : this.max_height,\r\n            activation : Object.keys(activation),\r\n            layer_act : this.layer_activation\r\n        }\r\n    }\r\n\r\n    export(){\r\n        let obj = {\r\n            learning_rate : this.learning_rate,\r\n            bias : this.bias\r\n        };\r\n        let weights = [];\r\n        this.layers.forEach(layer =>{\r\n            let l = [];\r\n            layer.forEach(node => l.push(node.edges))\r\n            weights.push(l);\r\n        })\r\n        obj.weights = weights\r\n        return obj;\r\n    }\r\n\r\n    import(obj){\r\n        this.layers = []\r\n        this.max_height = 0;\r\n        this.bias = obj.bias\r\n        this.learning_rate = obj.learning_rate\r\n        obj.weights.forEach(layer =>  {\r\n            let l = [];\r\n            layer.forEach(edges =>{\r\n                let node = {edges:edges,edges_old:[...edges]};\r\n                if(this.bias && l.length === layer.length-1 && this.layers.length !== obj.weights.length-1)\r\n                    node.value = 1;\r\n                l.push(node)\r\n            })\r\n            this.layers.push(l)\r\n            if(layer.length > this.max_height) this.max_height = layer.length\r\n        })\r\n        this.n_layers = this.layers.length\r\n    }\r\n\r\n\r\n}\r\n","C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Layout\\Layout.jsx",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Visual\\VisualNN.jsx",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Layout\\InfoPanel.jsx",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Layout\\Topbar\\Topbar.jsx",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Layout\\Topbar\\TopbarData.jsx",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Info\\InfoBasic.jsx",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Info\\Feedback.jsx",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\DataGrid\\DataGrid.jsx",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\DataGrid\\DataEntry.jsx",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\DataGrid\\DataValue.jsx",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\DataGrid\\DataAux.jsx",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\NeuralNetwork\\samplesNN.js",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Expression\\Expression.jsx",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\NeuralNetwork\\activation.js",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Visual\\LayerDropDown.jsx",[],"C:\\Users\\torre\\Desktop\\Projs\\NN_Visual\\nn-visual\\src\\components\\Info\\FeedForward.jsx",[],{"ruleId":"103","replacedBy":"104"},{"ruleId":"105","replacedBy":"106"},{"ruleId":"107","severity":1,"message":"108","line":391,"column":22,"nodeType":"109","messageId":"110","endLine":391,"endColumn":24},"no-native-reassign",["111"],"no-negated-in-lhs",["112"],"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","no-global-assign","no-unsafe-negation"]